package com.sky.hiwise.algorithms.leetcode.dynamic;

public class TargetSum494 {

    /**
     * 494. 目标和
     * 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。
     * 现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
     * 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
     * 示例 1:
     * 输入: nums: [1, 1, 1, 1, 1], S: 3
     * 输出: 5
     * 解释:
     * -1+1+1+1+1 = 3
     * +1-1+1+1+1 = 3
     * +1+1-1+1+1 = 3
     * +1+1+1-1+1 = 3
     * +1+1+1+1-1 = 3
     * 一共有5种方法让最终目标和为3。
     * 注意:
     * 数组非空，且长度不会超过20。
     * 初始的数组的和不会超过1000。
     * 保证返回的最终结果能被32位整数存下。
     * @param nums
     * @param S
     * @return
     */
    public int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for(int num : nums) {
            sum += num;
        }
        if (sum < S || (sum + S) % 2 != 0) {
            return 0;
        }
        int target = (sum + S) / 2;
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for(int num : nums) {
            for(int i = target; i >= num; i--) {
                dp[i] = dp[i] + dp[i - num];
            }
        }
        return dp[target];
    }

    /**
     * 该题难点在于，如何将其转换为背包问题。
     * 假设有集合 N 和 集合 P 使得 sum(N) - sum(P) = S 其中 N，P 均是输入数组的子集, 那么必然有
     * 2*sum(N) - sum(P) + sum(P) = S + sum(N) + sum(P)
     * =>
     * 2*sum(N) = S + sum(nums)
     * 所以我们只需要找到满足上述推论的集合 N 就 ok 了，
     * 即转换为问题：存在一个容量为 V 的背包，从 nums 中任意抽取一定数量的数，
     * 使得背包恰好被放满，有多少种放法。这个容量 V 我们通过上述的推导已经求出来了, V = sum(N)。
     */
    /**
     * 方法是
     * 开辟一个长度为P+1的数组，命名为dp
     * dp的第x项，代表组合成数字x有多少方法。比如说,dp[0] = 1，代表组合成0只有1中方法，即什么也不取。
     * 比如说dp[5] = 3 ，代表使总和加到5总共有三种方法。
     * 所以最后返回的就是dp[P]，代表组合成P的方法有多少种
     * 问题是
     * 怎么更新dp数组呢？
     * 遍历nums，遍历的数记作num
     * 再逆序遍历从P到num，遍历的数记作j
     * 更新dp[j] = dp[j - num] + dp[j]
     * 这样遍历的含义是，对每一个在nums数组中的数num而言，dp在从num到P的这些区间里，都可以加上一个num，来到达想要达成的P。
     * 举例来说，对于数组[1,2,3,4,5]，想要康康几种方法能组合成4,那么设置dp[0]到dp[4]的数组
     * 假如选择了数字2,那么dp[2:5]（也就是2到4）都可以通过加上数字2有所改变，而dp[0:2]（也就是0到1）加上这个2很明显就超了，就不管它。
     * 以前没有考虑过数字2,考虑了会怎么样呢？就要更新dp[2:5]，比如说当我们在更新dp[3]的时候，就相当于dp[3] = dp[3] + dp[1],
     * 即本来有多少种方法，加上去掉了2以后有多少种方法。因为以前没有考虑过2,现在知道，只要整到了1,就一定可以整到3。
     * 为什么以这个顺序来遍历呢？
     * 假如给定nums = [num1,num2,num3]，我们现在可以理解dp[j] = dp[j-num1] + dp[j-num2] + dp[j-num3]。
     * 但是如何避免不会重复计算或者少算？要知道，我们的nums并不是排序的，我们的遍历也不是从小到大的。
     * 我们不妨跟着流程走一遍
     * 第一次num1，仅仅更新了dp[num1] = 1，其他都是0+0都是0啊都是0
     * 第二次num2，更新了dp[num2] = 1和dp[num1+num2] = dp[num1+num2] + dp[num1] = 1,先更新后者。
     * 第三次num3，更新了dp[num3] = 1和dp[num1+num3] += 1和dp[num2+num3] += 1和dp[num1+num2+num3] += 1。按下标从大到小顺序来更新。
     */
}
