package com.sky.hiwise.algorithms.leetcode.graph.dfs;

import java.util.Arrays;

public class MinMalwareSpread924 {

    /**
     * 924. 尽量减少恶意软件的传播
     * 在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。
     * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
     * 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
     * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
     * 我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
     * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。
     * 示例 1：
     * 输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
     * 输出：0
     * 示例 2：
     * 输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
     * 输出：0
     * 示例 3：
     * 输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
     * 输出：1
     * @param graph
     * @param initial
     * @return
     */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        int[] colors = new int[N];
        Arrays.fill(colors, - 1);
        int c = 0; //联通分量的个数 颜色值
        //计算联通分量的个数
        for (int node = 0; node < N; node++) {
            if (colors[node] == -1) {
                dfs(graph, colors, node, c++);
            }
        }

        // 2. Size of each color.
        int[] colorSize = new int[c];
        for(int col : colors) {
            colorSize[col] ++;
        }

        // 3. Find unique colors.
        int[] colorCount = new int[c];
        for (int init : initial) {
            colorCount[colors[init]]++;
        }

        // 4. Answer
        int ans = Integer.MAX_VALUE;
        for (int init : initial) {
            int col = colors[init];
            if (colorCount[col] == 1) {
               if (ans == Integer.MAX_VALUE) {
                   ans = init;
               } else if (colorSize[col] > colorSize[colors[ans]]) {
                   ans = init;
               } else if (colorSize[col] == colorSize[colors[ans]] && init < ans) {
                   ans = init;
               }
            }
        }

        if (ans == Integer.MAX_VALUE) {
            for (int init : initial) {
                ans = Math.min(ans, init);
            }
        }
        return ans;
    }

    public void dfs(int[][] graph, int[] colors, int node, int color) {
        colors[node] = color;
        for (int i = 0; i < graph.length; i++) {
            if (graph[node][i] == 1 && colors[i] == -1) {
                dfs(graph, colors, i, color);
            }
        }
    }
    /**
     * 算法
     *
     * 算法包括以下几个部分：
     * 给连通分量上色： 遍历每个节点，如果它还没有颜色，就用深度优先搜索去遍历它所在的连通分量，同时给这个连通分量标上新的颜色。
     * 计算每个连通分量的大小： 数一下每个颜色的节点各有多少个。
     * 找到唯一的颜色： 找到 initial 中颜色唯一的节点。
     * 选择答案： 对于 initial 中颜色唯一的节点，计算这个颜色节点的个数。从中选出最大节点个数的那个，如果有多个最优解，选择其中节点下标最小的。
     * 如果没有颜色唯一的节点，直接返回 min(initial)。
     * 作者：LeetCode
     * 链接：https://leetcode-cn.com/problems/minimize-malware-spread/solution/jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-b-2/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     */

    public static void main(String[] args) {
        int[][] graph = new int[][]{{1,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,1}};
        int[] initial = new int[]{1, 3};
        System.out.println((new MinMalwareSpread924()).minMalwareSpread(graph, initial));
    }
}
